generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
}

model User {
  id            String         @id @default(cuid())
  email         String         @unique
  name          String?
  password      String?
  avatarUrl     String?
  twoFactorEnabled    Boolean   @default(false)
  twoFactorSecret     String?
  twoFactorTempSecret String?
  recoveryCodes       String?
  twoFactorVerifiedAt DateTime?
  emailAccounts EmailAccount[]
  pushChannels  PushChannel[]
  pushTemplates PushTemplate[]
  filterRules   FilterRule[]
  notifications Notification[]
  settings      UserSettings?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model UserSettings {
  id                   String   @id @default(cuid())
  userId               String   @unique
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailNotifications   Boolean  @default(true)
  pushNotifications    Boolean  @default(true)
  soundEnabled         Boolean  @default(false)
  quietHoursStart      String   @default("22:00")
  quietHoursEnd        String   @default("08:00")
  maxPerMinute         Int      @default(10)
  maxPerHour           Int      @default(100)
  twoFactorEnabled     Boolean  @default(false)
  sessionTimeout       Int      @default(30)
  language             String   @default("zh-CN")
  timezone             String   @default("Asia/Shanghai")
  dateFormat           String   @default("YYYY-MM-DD")
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

model EmailAccount {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  email             String
  provider          String
  imapHost          String
  imapPort          Int
  smtpHost          String?
  smtpPort          Int?
  encryptedPassword String
  isActive          Boolean   @default(true)
  lastSyncAt        DateTime?
  lastHeartbeatAt   DateTime?
  status            String    @default("connected")
  errorMessage      String?
  emails            Email[]
  pushChannels      PushChannel[]
  filterRules       FilterRule[]
  pushTemplates     PushTemplate[]
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([userId, email])
}

model Email {
  id             String       @id @default(cuid())
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  messageId      String       @unique
  fromAddress    String
  toAddresses    String
  subject        String
  body           String?
  bodyHtml       String?
  receivedAt     DateTime
  isRead         Boolean      @default(false)
  attachments    String?
  headers        String?
  pushLogs       PushLog[]
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([emailAccountId, receivedAt])
  @@index([isRead])
}

model PushChannel {
  id             String       @id @default(cuid())
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAccountId String?
  emailAccount   EmailAccount? @relation(fields: [emailAccountId], references: [id], onDelete: SetNull)
  templateId     String?
  template       PushTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  type           String
  name           String
  config         String
  isActive       Boolean      @default(true)
  cardTemplate   String?
  pushLogs       PushLog[]
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([userId, emailAccountId, type])
}

model FilterRule {
  id             String       @id @default(cuid())
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAccountId String?
  emailAccount   EmailAccount? @relation(fields: [emailAccountId], references: [id], onDelete: SetNull)
  name           String
  isActive       Boolean      @default(true)
  conditions     String
  actions        String
  priority       Int          @default(0)
  matchCount     Int          @default(0)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([userId, emailAccountId, priority])
}

model PushTemplate {
  id             String       @id @default(cuid())
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAccountId String?
  emailAccount   EmailAccount? @relation(fields: [emailAccountId], references: [id], onDelete: SetNull)
  name           String
  type           String
  content        String
  isDefault      Boolean      @default(false)
  isActive       Boolean      @default(true)
  channels       PushChannel[]
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([userId, emailAccountId, type, isActive])
}

model PushLog {
  id           String      @id @default(cuid())
  emailId      String
  email        Email       @relation(fields: [emailId], references: [id], onDelete: Cascade)
  channelId    String
  channel      PushChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  status       String
  errorMessage String?
  pushedAt     DateTime    @default(now())

  @@index([emailId])
  @@index([channelId])
}

model RateLimitLog {
  id          String   @id @default(cuid())
  channelId   String
  count       Int      @default(1)
  windowStart DateTime
  createdAt   DateTime @default(now())

  @@unique([channelId, windowStart])
}

model SystemAlert {
  id         String    @id @default(cuid())
  type       String
  severity   String
  message    String
  metadata   String?
  isResolved Boolean   @default(false)
  createdAt  DateTime  @default(now())
  resolvedAt DateTime?
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  title     String
  message   String
  type      String   @default("info")
  isRead    Boolean  @default(false)
  metadata  String?
  readAt    DateTime?
  createdAt DateTime @default(now())

  @@index([userId, isRead, createdAt])
}
